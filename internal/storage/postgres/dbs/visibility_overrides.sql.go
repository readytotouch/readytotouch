// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: visibility_overrides.sql

package dbs

import (
	"context"
	"time"
)

const userCompanyVisibilityOverrideHistoryNew = `-- name: UserCompanyVisibilityOverrideHistoryNew :exec
INSERT INTO user_company_visibility_override_history (user_id, company_id, visibility, created_at)
VALUES ($1, $2, $3, $4)
`

type UserCompanyVisibilityOverrideHistoryNewParams struct {
	UserID     int64
	CompanyID  int64
	Visibility bool
	CreatedAt  time.Time
}

func (q *Queries) UserCompanyVisibilityOverrideHistoryNew(ctx context.Context, arg UserCompanyVisibilityOverrideHistoryNewParams) error {
	_, err := q.exec(ctx, q.userCompanyVisibilityOverrideHistoryNewStmt, userCompanyVisibilityOverrideHistoryNew,
		arg.UserID,
		arg.CompanyID,
		arg.Visibility,
		arg.CreatedAt,
	)
	return err
}

const userCompanyVisibilityOverrideUpsert = `-- name: UserCompanyVisibilityOverrideUpsert :execrows
INSERT INTO user_company_visibility_overrides AS t (user_id, company_id, visibility, created_at, updated_at)
VALUES ($1, $2, $3, $4, $4)
ON CONFLICT (user_id, company_id) DO UPDATE
    SET visibility = excluded.visibility,
        updated_at = excluded.updated_at
WHERE t.visibility <> excluded.visibility
`

type UserCompanyVisibilityOverrideUpsertParams struct {
	UserID     int64
	CompanyID  int64
	Visibility bool
	CreatedAt  time.Time
}

func (q *Queries) UserCompanyVisibilityOverrideUpsert(ctx context.Context, arg UserCompanyVisibilityOverrideUpsertParams) (int64, error) {
	result, err := q.exec(ctx, q.userCompanyVisibilityOverrideUpsertStmt, userCompanyVisibilityOverrideUpsert,
		arg.UserID,
		arg.CompanyID,
		arg.Visibility,
		arg.CreatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const userCompanyVisibilityOverrides = `-- name: UserCompanyVisibilityOverrides :many
SELECT company_id
FROM user_company_visibility_overrides
WHERE user_id = $1
  AND visibility = true
`

func (q *Queries) UserCompanyVisibilityOverrides(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.userCompanyVisibilityOverridesStmt, userCompanyVisibilityOverrides, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var company_id int64
		if err := rows.Scan(&company_id); err != nil {
			return nil, err
		}
		items = append(items, company_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userIndustryVisibilityOverrideHistoryNew = `-- name: UserIndustryVisibilityOverrideHistoryNew :exec
INSERT INTO user_industry_visibility_override_history (user_id, industry_id, visibility, created_at)
VALUES ($1, $2, $3, $4)
`

type UserIndustryVisibilityOverrideHistoryNewParams struct {
	UserID     int64
	IndustryID int64
	Visibility bool
	CreatedAt  time.Time
}

func (q *Queries) UserIndustryVisibilityOverrideHistoryNew(ctx context.Context, arg UserIndustryVisibilityOverrideHistoryNewParams) error {
	_, err := q.exec(ctx, q.userIndustryVisibilityOverrideHistoryNewStmt, userIndustryVisibilityOverrideHistoryNew,
		arg.UserID,
		arg.IndustryID,
		arg.Visibility,
		arg.CreatedAt,
	)
	return err
}

const userIndustryVisibilityOverrideUpsert = `-- name: UserIndustryVisibilityOverrideUpsert :execrows
INSERT INTO user_industry_visibility_overrides AS t (user_id, industry_id, visibility, created_at, updated_at)
VALUES ($1, $2, $3, $4, $4)
ON CONFLICT (user_id, industry_id) DO UPDATE
    SET visibility = excluded.visibility,
        updated_at = excluded.updated_at
WHERE t.visibility <> excluded.visibility
`

type UserIndustryVisibilityOverrideUpsertParams struct {
	UserID     int64
	IndustryID int64
	Visibility bool
	CreatedAt  time.Time
}

func (q *Queries) UserIndustryVisibilityOverrideUpsert(ctx context.Context, arg UserIndustryVisibilityOverrideUpsertParams) (int64, error) {
	result, err := q.exec(ctx, q.userIndustryVisibilityOverrideUpsertStmt, userIndustryVisibilityOverrideUpsert,
		arg.UserID,
		arg.IndustryID,
		arg.Visibility,
		arg.CreatedAt,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const userIndustryVisibilityOverrides = `-- name: UserIndustryVisibilityOverrides :many
SELECT industry_id
FROM user_industry_visibility_overrides
WHERE user_id = $1
  AND visibility = true
`

func (q *Queries) UserIndustryVisibilityOverrides(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.userIndustryVisibilityOverridesStmt, userIndustryVisibilityOverrides, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var industry_id int64
		if err := rows.Scan(&industry_id); err != nil {
			return nil, err
		}
		items = append(items, industry_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
