// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package dbs

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const socialUserProfiles = `-- name: SocialUserProfiles :many
SELECT s.social_provider,
       s.social_provider_user_id,
       s.username,
       s.name,
       s.created_at
FROM user_social_profiles s
WHERE (
       $1::BOOLEAN = FALSE
    OR s.social_provider = ANY ($2::SOCIAL_PROVIDER[])
  )
  AND s.deleted_at IS NULL
ORDER BY s.id DESC
LIMIT $3
`

type SocialUserProfilesParams struct {
	SocialProviderFilterExists bool
	SocialProviders            []SocialProvider
	Limit                      int32
}

type SocialUserProfilesRow struct {
	SocialProvider       SocialProvider
	SocialProviderUserID string
	Username             string
	Name                 string
	CreatedAt            time.Time
}

func (q *Queries) SocialUserProfiles(ctx context.Context, arg SocialUserProfilesParams) ([]SocialUserProfilesRow, error) {
	rows, err := q.query(ctx, q.socialUserProfilesStmt, socialUserProfiles, arg.SocialProviderFilterExists, pq.Array(arg.SocialProviders), arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SocialUserProfilesRow
	for rows.Next() {
		var i SocialUserProfilesRow
		if err := rows.Scan(
			&i.SocialProvider,
			&i.SocialProviderUserID,
			&i.Username,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const socialUserProfilesByUser = `-- name: SocialUserProfilesByUser :many
SELECT s.social_provider,
       s.social_provider_user_id,
       s.username,
       s.name,
       s.created_at
FROM user_social_profiles s
WHERE s.user_id = $1
  AND s.deleted_at IS NULL
ORDER BY s.id
`

type SocialUserProfilesByUserRow struct {
	SocialProvider       SocialProvider
	SocialProviderUserID string
	Username             string
	Name                 string
	CreatedAt            time.Time
}

func (q *Queries) SocialUserProfilesByUser(ctx context.Context, userID int64) ([]SocialUserProfilesByUserRow, error) {
	rows, err := q.query(ctx, q.socialUserProfilesByUserStmt, socialUserProfilesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SocialUserProfilesByUserRow
	for rows.Next() {
		var i SocialUserProfilesByUserRow
		if err := rows.Scan(
			&i.SocialProvider,
			&i.SocialProviderUserID,
			&i.Username,
			&i.Name,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userRegistrationDailyCountStats = `-- name: UserRegistrationDailyCountStats :many
SELECT days.day::DATE                    AS day,
       COALESCE(s.user_count, 0)::BIGINT AS user_count
FROM GENERATE_SERIES(
    $1::DATE,
    $2::DATE,
    '1 DAY'::INTERVAL
) AS days (day)
    LEFT JOIN (
        SELECT DATE_TRUNC('DAY', created_at) AS day,
               COUNT(*)                      AS user_count
        FROM users
        WHERE created_at >= $1::DATE
        GROUP BY day
    ) AS s ON (days.day = s.day)
ORDER BY days.day
`

type UserRegistrationDailyCountStatsParams struct {
	From time.Time
	To   time.Time
}

type UserRegistrationDailyCountStatsRow struct {
	Day       time.Time
	UserCount int64
}

func (q *Queries) UserRegistrationDailyCountStats(ctx context.Context, arg UserRegistrationDailyCountStatsParams) ([]UserRegistrationDailyCountStatsRow, error) {
	rows, err := q.query(ctx, q.userRegistrationDailyCountStatsStmt, userRegistrationDailyCountStats, arg.From, arg.To)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserRegistrationDailyCountStatsRow
	for rows.Next() {
		var i UserRegistrationDailyCountStatsRow
		if err := rows.Scan(&i.Day, &i.UserCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userSocialProfileChangeHistoryNew = `-- name: UserSocialProfileChangeHistoryNew :exec
INSERT INTO user_social_profile_change_history (user_id, user_social_profile_id, email, username, name, created_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type UserSocialProfileChangeHistoryNewParams struct {
	UserID              int64
	UserSocialProfileID int64
	Email               string
	Username            string
	Name                string
	CreatedAt           time.Time
}

func (q *Queries) UserSocialProfileChangeHistoryNew(ctx context.Context, arg UserSocialProfileChangeHistoryNewParams) error {
	_, err := q.exec(ctx, q.userSocialProfileChangeHistoryNewStmt, userSocialProfileChangeHistoryNew,
		arg.UserID,
		arg.UserSocialProfileID,
		arg.Email,
		arg.Username,
		arg.Name,
		arg.CreatedAt,
	)
	return err
}

const userSocialProfileGetByID = `-- name: UserSocialProfileGetByID :one
SELECT usp.id, usp.user_id, usp.email, usp.username, usp.name
FROM user_social_profiles usp
WHERE usp.social_provider = $1
  AND usp.social_provider_user_id = $2
  AND usp.deleted_at IS NULL
    FOR UPDATE
`

type UserSocialProfileGetByIDParams struct {
	SocialProvider       SocialProvider
	SocialProviderUserID string
}

type UserSocialProfileGetByIDRow struct {
	ID       int64
	UserID   int64
	Email    string
	Username string
	Name     string
}

func (q *Queries) UserSocialProfileGetByID(ctx context.Context, arg UserSocialProfileGetByIDParams) (UserSocialProfileGetByIDRow, error) {
	row := q.queryRow(ctx, q.userSocialProfileGetByIDStmt, userSocialProfileGetByID, arg.SocialProvider, arg.SocialProviderUserID)
	var i UserSocialProfileGetByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Email,
		&i.Username,
		&i.Name,
	)
	return i, err
}

const userSocialProfileGetUserByEmail = `-- name: UserSocialProfileGetUserByEmail :one
SELECT usp.user_id
FROM user_social_profiles usp
WHERE usp.email = LOWER($1)
  AND usp.deleted_at IS NULL
ORDER BY usp.id DESC
LIMIT 1
`

func (q *Queries) UserSocialProfileGetUserByEmail(ctx context.Context, email string) (int64, error) {
	row := q.queryRow(ctx, q.userSocialProfileGetUserByEmailStmt, userSocialProfileGetUserByEmail, email)
	var user_id int64
	err := row.Scan(&user_id)
	return user_id, err
}

const userSocialProfileNew = `-- name: UserSocialProfileNew :one
INSERT INTO user_social_profiles (user_id, social_provider, social_provider_user_id, email, username, name, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $7)
RETURNING id
`

type UserSocialProfileNewParams struct {
	UserID               int64
	SocialProvider       SocialProvider
	SocialProviderUserID string
	Email                string
	Username             string
	Name                 string
	CreatedAt            time.Time
}

func (q *Queries) UserSocialProfileNew(ctx context.Context, arg UserSocialProfileNewParams) (int64, error) {
	row := q.queryRow(ctx, q.userSocialProfileNewStmt, userSocialProfileNew,
		arg.UserID,
		arg.SocialProvider,
		arg.SocialProviderUserID,
		arg.Email,
		arg.Username,
		arg.Name,
		arg.CreatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const userSocialProfileUpdate = `-- name: UserSocialProfileUpdate :exec
UPDATE user_social_profiles
SET email      = LOWER($1),
    username   = $2,
    name       = $3,
    updated_at = $4
WHERE id = $5
`

type UserSocialProfileUpdateParams struct {
	Email     string
	Username  string
	Name      string
	UpdatedAt time.Time
	ID        int64
}

func (q *Queries) UserSocialProfileUpdate(ctx context.Context, arg UserSocialProfileUpdateParams) error {
	_, err := q.exec(ctx, q.userSocialProfileUpdateStmt, userSocialProfileUpdate,
		arg.Email,
		arg.Username,
		arg.Name,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const usersNew = `-- name: UsersNew :one
INSERT INTO users (created_at, updated_at)
VALUES ($1, $1)
RETURNING id
`

func (q *Queries) UsersNew(ctx context.Context, createdAt time.Time) (int64, error) {
	row := q.queryRow(ctx, q.usersNewStmt, usersNew, createdAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const usersUpdate = `-- name: UsersUpdate :exec
UPDATE users
SET updated_at = $1
WHERE id = $2
`

type UsersUpdateParams struct {
	UpdatedAt time.Time
	ID        int64
}

func (q *Queries) UsersUpdate(ctx context.Context, arg UsersUpdateParams) error {
	_, err := q.exec(ctx, q.usersUpdateStmt, usersUpdate, arg.UpdatedAt, arg.ID)
	return err
}
